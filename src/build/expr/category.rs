// Copyright 2015 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use syntax::ast::{self, ExprKind};

#[derive(Debug, PartialEq)]
pub enum Category {
    // An assignable memory location like `x`, `x.f`, `foo()[3]`, that
    // sort of thing. Something that could appear on the LHS of an `=`
    // sign.
    Lvalue,

    // A literal like `23` or `"foo"`. Does not include constant
    // expressions like `3 + 5`.
    Constant,

    // Something that generates a new value at runtime, like `x + y`
    // or `foo()`.
    Rvalue(RvalueFunc),
}

// Rvalues fall into different "styles" that will determine which fn
// is best suited to generate them.
#[derive(Debug, PartialEq)]
pub enum RvalueFunc {
    // Best generated by `into`. This is generally exprs that
    // cause branching, like `match`, but also includes calls.
    Into,

    // Best generated by `as_rvalue`. This is usually the case.
    AsRvalue,
}

/// Determines the category for a given expression. Note that scope
/// and paren expressions have no category.
impl Category {
    pub fn of(ek: &ExprKind) -> Option<Category> {
        match *ek {
            ExprKind::Paren(..) => None,

            ExprKind::Field(..) |
            ExprKind::TupField(..) |
            ExprKind::Unary(ast::UnOp::Deref, _) |
            ExprKind::Index(..) |
            ExprKind::Path(..) =>
                Some(Category::Lvalue),

            ExprKind::If(..) |
            ExprKind::IfLet(..) |
            ExprKind::Match(..) |
            ExprKind::Try(..) |
            ExprKind::Call(..) |
            ExprKind::MethodCall(..) |
            ExprKind::ForLoop(..) |
            ExprKind::While(..) |
            ExprKind::WhileLet(..) |
            ExprKind::Mac(..) =>
                Some(Category::Rvalue(RvalueFunc::Into)),

            ExprKind::Array(..) |
            ExprKind::Tup(..) |
            ExprKind::Struct(..) |
            ExprKind::Range(..) |
            ExprKind::Closure(..) |
            ExprKind::Unary(..) |
            ExprKind::Binary(..) |
            ExprKind::Box(..) |
            ExprKind::Cast(..) |
            ExprKind::Repeat(..) |
            ExprKind::AddrOf(..) |
            ExprKind::Assign(..) |
            ExprKind::AssignOp(..) |
            ExprKind::InlineAsm(..) =>
                Some(Category::Rvalue(RvalueFunc::AsRvalue)),

            ExprKind::Lit(..) =>
                Some(Category::Constant),

            ExprKind::Loop(..) |
            ExprKind::Block(..) |
            ExprKind::Break(..) |
            ExprKind::Continue(..) |
            ExprKind::Ret(..) =>
                // FIXME(#27840) these probably want their own
                // category, like "nonterminating"
                Some(Category::Rvalue(RvalueFunc::Into)),

            ExprKind::InPlace(..) |
            ExprKind::Type(..) =>
                panic!("not supported yet: {:?}", ek)
            
        }
    }
}
